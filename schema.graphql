type Account @entity {
  id: Bytes!
  address: Bytes!
  transfersIn: [Transfer!]! @derivedFrom(field: "to")
  transfersOut: [Transfer!]! @derivedFrom(field: "from")
  vaultBalances: [VaultBalance!]! @derivedFrom(field: "owner")
  receiptBalances: [ReceiptOwnerBalance!]! @derivedFrom(field: "owner")
  totalCyBalance: BigInt! # Sum of all token balances
  eligibleShare: BigDecimal! # Percentage of total eligible supply (if positive balance)
  liquidityBalances: [LiquidityOwnerBalance!]! @derivedFrom(field: "owner")
  liquidityV3Balances: [LiquidityV3OwnerBalance!]! @derivedFrom(field: "owner")
  liquidityV2Balances: [LiquidityV2OwnerBalance!]! @derivedFrom(field: "owner")
  liquidityChanges: [LiquidityChange!]! @derivedFrom(field: "owner")
  totalCyBalanceSnapshot: BigInt!
  eligibleShareSnapshot: BigDecimal!
}

type Transfer @entity(immutable: true) {
  id: Bytes!
  tokenAddress: Bytes!
  from: Account!
  fromIsApprovedSource: Boolean!
  to: Account!
  value: BigInt!
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  transactionHash: Bytes!
}

type EligibleTotals @entity {
  id: String!
  totalEligibleSum: BigInt! # Sum of all positive vault balances across all accounts
  totalEligibleSumSnapshot: BigInt! # Total sum of token snapshots
}

type VaultBalance @entity {
  id: Bytes! # composite of vaultAddress + owner
  vault: CycloVault!
  owner: Account!
  balance: BigInt!
  balanceAvgSnapshot: BigInt!
}

type ReceiptOwnerBalance @entity {
  id: Bytes! # composite of receiptAddress + tokenId + owner
  receipt: CycloReceipt!
  receiptAddress: Bytes!
  tokenId: BigInt!
  owner: Account!
  balance: BigInt!
}

type CycloVault @entity {
  id: Bytes!
  address: Bytes!
  deployBlock: BigInt!
  deployTimestamp: BigInt!
  deployer: Bytes!
  totalEligible: BigInt! # Sum of all positive balances for this vault across all accounts
  totalEligibleSnapshot: BigInt! # Total sum of account snapshots for the token
}

type CycloReceipt @entity {
  id: Bytes!
  address: Bytes!
  deployBlock: BigInt!
  deployTimestamp: BigInt!
  deployer: Bytes!
}

interface LiquidityOwnerBalance {
  id: Bytes! # composite of lp address + tokenAddress + owner + tokenId(in case of v3)
  lpAddress: Bytes!
  owner: Account!
  depositBalance: BigInt!
  liquidity: BigInt!
  tokenAddress: Bytes! # cy token address
}

type LiquidityV2OwnerBalance implements LiquidityOwnerBalance @entity {
  id: Bytes! # composite of lp address + tokenAddress + owner
  lpAddress: Bytes!
  owner: Account!
  depositBalance: BigInt!
  liquidity: BigInt!
  tokenAddress: Bytes! # cy token address
}

type LiquidityV3OwnerBalance implements LiquidityOwnerBalance @entity {
  id: Bytes! # composite of lp address + tokenAddress + owner + tokenId
  lpAddress: Bytes!
  owner: Account!
  depositBalance: BigInt!
  liquidity: BigInt!
  tokenAddress: Bytes! # cy token address
  tokenId: BigInt!
  poolAddress: Bytes!
  fee: Int!
  lowerTick: Int!
  upperTick: Int!
}

enum LiquidityChangeType {
  DEPOSIT
  WITHDRAW
  TRANSFER
}

interface LiquidityChange {
  id: Bytes!
  tokenAddress: Bytes! # cyclo token address
  lpAddress: Bytes!
  owner: Account!
  depositedBalanceChange: BigInt! # amount of original deposited token value that effectvely was transfered due to this liquidity transfer
  liquidityChange: BigInt!
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  transactionHash: Bytes!
  liquidityChangeType: LiquidityChangeType!
}

type LiquidityV2Change implements LiquidityChange @entity(immutable: true) {
  id: Bytes!
  tokenAddress: Bytes! # cyclo token address
  lpAddress: Bytes!
  owner: Account!
  depositedBalanceChange: BigInt! # amount of original deposited token value that effectvely was transfered due to this liquidity transfer
  liquidityChange: BigInt!
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  transactionHash: Bytes!
  liquidityChangeType: LiquidityChangeType!
}

type LiquidityV3Change implements LiquidityChange @entity(immutable: true) {
  id: Bytes!
  tokenAddress: Bytes! # cyclo token address
  lpAddress: Bytes!
  owner: Account!
  depositedBalanceChange: BigInt! # amount of original deposited token value that effectvely was transfered due to this liquidity transfer
  liquidityChange: BigInt!
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  transactionHash: Bytes!
  liquidityChangeType: LiquidityChangeType!
  tokenId: BigInt!
}

type AccountsMetadata @entity {
  id: String!
  accounts: [Bytes!]! # list of all accounts
}

# entity to keep the time state between event triggers
# a single record of this entity gets created on origin
# event (first ever event trigger) and then is updated
# throughout the sync process
type TimeState @entity {
  id: String!
  originTimestamp: BigInt! # The first ever event block timestamp
  originBlock: BigInt! # The first ever event block number
  currentTimestamp: BigInt! # Timestamp of the latest triggered event (current working state)
  currentBlock: BigInt! # Block number of the latest triggered event (current working state)
  prevTimestamp: BigInt! # Timestamp of the previous triggered event
  prevBlock: BigInt! # Block number of the previous triggered event
  lastSnapshotEpoch: Int!
  lastSnapshotDayOfEpoch: Int!
}
